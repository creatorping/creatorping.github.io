---
title: C++11
data: 2020-10-21 14:59:00 +0800
categories: [后端之路,C++面试基础]
tags: [C++面试基础]
---
## <font color=Blue>请问C++11有哪些新特性？</font>

C++11 最常用的新特性如下：

auto关键字：编译器可以根据初始值自动推导出类型。但是不能用于函数传参以及数组类型的推导

nullptr关键字：nullptr是一种特殊类型的字面值，它可以被转换成任意其它的指针类型；而NULL一般被宏定义为0，在遇到重载时可能会出现问题。

智能指针：C++11新增了std::shared_ptr、std::weak_ptr等类型的智能指针，用于解决内存管理的问题。

初始化列表：使用初始化列表来对类进行初始化

右值引用：基于右值引用可以实现移动语义和完美转发，消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率

atomic原子操作用于多线程资源互斥操作

新增STL容器array以及tuple

## <font color=Blue>介绍一下C++11中的可变参数模板、右值引用和lambda这几个新特性。</font>

**可变参数模板：**[较为全面的博客](https://blog.csdn.net/tony__lin/article/details/84677316)

~~~C++
#include <stdio.h>
#include <string.h>
#include <iostream>
#include <algorithm>
using namespace std;
template <class... T>
void f(T... args)
{
    cout << sizeof...(args) << endl; //打印变参的个数
}
int main()
{
    f(0);        //0
    f(1, 2);    //2
    f(1, 2.5);    //3
}
~~~

省略号作用如下：

+ 1）声明一个包含0到任意个模板参数的参数包

+ 2）在模板定义得右边，可以将参数包展成一个个独立的参数

C++11可以使用递归函数的方式展开参数包，获得可变参数的每个值。通过递归函数展开参数包，需要提供一个参数包展开的函数和一个递归终止函数。例如：

~~~C++
#include <stdio.h>
#include <string.h>
#include <iostream>
#include <algorithm>
using namespace std;
void print()
{
    cout << "empty" << endl;
}
//展开函数
template <class T, class... Args>
void print(T head, Args... rest)
{
    cout << "parameter " << head << endl;
    print(rest...);
}
int main()
{
    print(1, 2, 3, 4);
    return 0;
}
~~~

**右值引用:**

右值引用:

C++中，左值通常指可以取地址，有名字的值就是左值，而不能取地址，没有名字的就是右值。而在指C++11中，右值是由两个概念构成，将亡值和纯右值。纯右值是用于识别临时变量和一些不跟对象关联的值，比如1+3产生的临时变量值，2、true等，而将亡值通常是指具有转移语义的对象，比如返回右值引用T&&的函数返回值等。

C++11中，右值引用就是对一个右值进行引用的类型。由于右值通常不具有名字，所以我们一般只能通过右值表达式获得其引用，比如：

T && a=ReturnRvale();

假设ReturnRvalue()函数返回一个右值，那么上述语句声明了一个名为a的右值引用，其值等于ReturnRvalue函数返回的临时变量的值。

基于右值引用可以实现`转移语义`和`完美转发`新特性。

**移动语义：**

对于一个包含指针成员变量的类，由于编译器默认的拷贝构造函数都是浅拷贝，所有我们一般需要通过实现深拷贝的拷贝构造函数，为指针成员分配新的内存并进行内容拷贝，从而避免悬挂指针的问题。

但是如下列代码所示：

![img](https://uploadfiles.nowcoder.com/images/20190911/826546_1568191321535_58A744363913E79F3AD5742FA81DCBAE)

当类HasPtrMem包含一个成员函数GetTemp,其返回值类型是HasPtrMem,如果我们定义了深拷贝的拷贝构造函数，那么在调用该函数时需要调用两次拷贝构造函数。第一次是生成GetTemp函数返回时的临时变量，第二次是将该返回值赋值给main函数中的变量a。与此对应需要调用三次析构函数来释放内存。

而在上述过程中，使用临时变量构造a时会调用拷贝构造函数分配对内存，而临时对象在语句结束后会释放它所使用的堆内存。这样重复申请和释放内存，在申请内存较大时会严重影响性能。因此C++使用移动构造函数，从而保证使用临时对象构造a时不分配内存，从而提高性能。

如下列代码所示，移动构造函数接收一个右值引用作为参数，使用右值引用的参数初始化其指针成员变量。

![img](https://uploadfiles.nowcoder.com/images/20190911/826546_1568191343421_462F4D51399618549AADC7EEFD2558BD)

其原理就是使用在构造对象a时，使用h.d来初始化a，然后将临时对象h的成员变量d指向nullptr，从而保证临时变量析构时不会释放对内存。

![img](https://uploadfiles.nowcoder.com/images/20190911/826546_1568191352653_88EEF7DC9BD18B099C522481527F5CE3)

**完美转发：**

完美转发是指在函数模板中，完全依照模板的参数的类型，将参数传递给函数模板中调用的另一个函数，即传入转发函数的是左值对象，目标函数就能获得左值对象，转发函数是右值对象，目标函数就能获得右值对象，而不产生额外的开销。

因此转发函数和目标函数参数一般采用引用类型，从而避免拷贝的开销。其次，由于目标函数可能需要能够既接受左值引用，又接受右值引用，所以考虑转发也需要兼容这两种类型。

C++11采用引用折叠的规则，结合新的模板推导规则实现完美转发。其引用折叠规则如下：

![img](https://uploadfiles.nowcoder.com/images/20190911/826546_1568191363531_0FAB347499C02FF2A53B2E5719DFFDCE)

因此，我们将转发函数和目标函数的参数都设置为右值引用类型，

![img](https://uploadfiles.nowcoder.com/images/20190911/826546_1568191372436_751F242F40E83204A02C51EE6E6F59C8)

当传入一个X类型的左值引用时，转发函数将被实例为：

![img](https://uploadfiles.nowcoder.com/images/20190911/826546_1568191379108_56A9F9A6063E926522868B216C5723C3)

经过引用折叠，变为：

![img](https://uploadfiles.nowcoder.com/images/20190911/826546_1568191386307_6474E6FC6FFC82F2E36AEDF32C2A9AF7)

当传入一个X类型的右值引用时，转发函数将被实例为：

![img](https://uploadfiles.nowcoder.com/images/20190911/826546_1568191392964_29CEF6AA3EFA9DA07FEFD9FAA986A303)

经过引用折叠，变为：

![img](https://uploadfiles.nowcoder.com/images/20190911/826546_1568191399205_49C2489FE4420DAECF6D97BFE94F06EE)

除此之外，还可以使用forward()函数来完成左值引用到右值引用的转换：

![img](https://uploadfiles.nowcoder.com/images/20190911/826546_1568191407573_A2019744F42C6BE3527BE38B3D0CD1EE)