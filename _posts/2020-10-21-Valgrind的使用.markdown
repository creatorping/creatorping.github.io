---
title: Valgrind的使用
data: 2020-10-21 21:59:00 +0800
categories: [编程语言,valgrind]
tags: [valgrind]
---

## 安装

>sudo apt  install valgrind

## Valgrind命令

**用法: valgrind [options] prog-and-args** 

`[options]:` 常用选项，适用于所有Valgrind工具

+ -tool=<name> 最常用的选项。运行 valgrind中名为toolname的工具。默认memcheck。

> memcheck ------> 这是valgrind应用最广泛的工具，一个重量级的内存检查器，能够发现开发中绝大多数内存错误使用情况，比如：使用未初始化的内存，使用已经释放了的内存，内存访问越界等。
>
> callgrind ------> 它主要用来检查程序中函数调用过程中出现的问题。cachegrind ------> 它主要用来检查程序中缓存使用出现的问题。
>
> helgrind ------> 它主要用来检查多线程程序中出现的竞争问题。
>
> massif ------> 它主要用来检查程序中堆栈使用中出现的问题。
>
> extension ------> 可以利用core提供的功能，自己编写特定的内存调试工具

  >-h –help 显示帮助信息。
  -version 显示valgrind内核的版本，每个工具都有各自的版本。
  -q –quiet 安静地运行，只打印错误信息。
  -v –verbose 更详细的信息, 增加错误数统计。
  -trace-children=no|yes 跟踪子线程? [no]
  -track-fds=no|yes 跟踪打开的文件描述？[no]
  -time-stamp=no|yes 增加时间戳到LOG信息? [no]
  -log-fd=<number> 输出LOG到描述符文件 [2=stderr]
  -log-file=<file> 将输出的信息写入到filename.PID的文件里，PID是运行程序的进行ID
  -log-file-exactly=<file> 输出LOG信息到 file
  -log-file-qualifier=<VAR> 取得环境变量的值来做为输出信息的文件名。 [none]
  -log-socket=ipaddr:port 输出LOG到socket ，ipaddr:port

LOG信息输出

  >-xml=yes 将信息以xml格式输出，只有memcheck可用
  -num-callers=<number> show <number> callers in stack traces [12]
  -error-limit=no|yes 如果太多错误，则停止显示新错误? [yes]
  -error-exitcode=<number> 如果发现错误则返回错误代码 [0=disable]
  -db-attach=no|yes 当出现错误，valgrind会自动启动调试器gdb。[no]
  -db-command=<command> 启动调试器的命令行选项[gdb -nw %f %p]

适用于Memcheck工具的相关选项：

  >-leak-check=no|summary|full 要求对leak给出详细信息? [summary]
  -leak-resolution=low|med|high how much bt merging in leak check [low]
  -show-reachable=no|yes show reachable blocks in leak check? [no]

 

最常用的命令格式：

> valgrind --tool=memcheck --leak-check=full ./test

## 示例

~~~c++
#include <stdio.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
struct node
{
    int a;
};
int main()
{
    node *q=new node();
    return 0;
}
~~~

>g++ q3.cpp -o q3
>valgrind --tool=memcheck --leak-check=full ./q3

**输出**

==32520== Memcheck, a memory error detector
==32520== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==32520== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info
==32520== Command: ./q3
==32520== 
==32520== 
==32520== HEAP SUMMARY:
==32520==     in use at exit: 4 bytes in 1 blocks
==32520==   total heap usage: 2 allocs, 1 frees, 72,708 bytes allocated
==32520== 
==32520== 4 bytes in 1 blocks are definitely lost in loss record 1 of 1
==32520==    at 0x483BE63: operator new(unsigned long) (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==32520==    by 0x10915E: main (in /home/creatorping/c++ file/test/q3)
==32520== 
==32520== LEAK SUMMARY:
==32520==    definitely lost: 4 bytes in 1 blocks
==32520==    indirectly lost: 0 bytes in 0 blocks
==32520==      possibly lost: 0 bytes in 0 blocks
==32520==    still reachable: 0 bytes in 0 blocks
==32520==         suppressed: 0 bytes in 0 blocks
==32520== 
==32520== For lists of detected and suppressed errors, rerun with: -s
==32520== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)

 Memcheck将内存泄露分为两种，一种是可能的内存泄露（Possibly lost），另外一种是确定的内存泄露（Definitely lost）。Possibly lost 是指仍然存在某个指针能够访问某块内存，但该指针指向的已经不是该内存首地址。Definitely lost 是指已经不能够访问这块内存。而Definitely lost又分为两种：直接的（direct）和间接的（indirect）。直接和间接的区别就是，直接是没有任何指针指向该内存，间接是指指向该内存的指针都位于内存泄露处。在上述的例子中，根节点是directly lost，而其他节点是indirectly lost

