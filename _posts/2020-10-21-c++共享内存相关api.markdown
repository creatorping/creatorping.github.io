---
title: 共享内存相关api
data: 2020-10-21 22:59:00 +0800
categories: [编程语言,C++从入门到放弃]
tags: [C++从入门到放弃]
---
Linux允许不同进程访问同一个逻辑内存，提供了一组API，头文件在sys/shm.h中。

## 1）新建共享内存shmget

int shmget(key_t key,size_t size,int shmflg);

key：共享内存键值，可以理解为共享内存的唯一性标记。

size：共享内存大小

shmflag：创建进程和其他进程的读写权限标识。

返回值：相应的共享内存标识符，失败返回-1

## 2）连接共享内存到当前进程的地址空间shmat

void *shmat(int shm_id,const void *shm_addr,int shmflg);

shm_id：共享内存标识符

shm_addr：指定共享内存连接到当前进程的地址，通常为0，表示由系统来选择。

shmflg：标志位

返回值：指向共享内存第一个字节的指针，失败返回-1

## 3）当前进程分离共享内存shmdt

int shmdt(const void *shmaddr);

## 4）控制共享内存shmctl

和信号量的semctl函数类似，控制共享内存

int shmctl(int shm_id,int command,struct shmid_ds *buf);

shm_id：共享内存标识符

command: 有三个值

IPC_STAT:获取共享内存的状态，把共享内存的shmid_ds结构复制到buf中。

IPC_SET:设置共享内存的状态，把buf复制到共享内存的shmid_ds结构。

IPC_RMID:删除共享内存

buf：共享内存管理结构体。

## key_t键和ftok函数

key_t ftok(const char *pathname, int proj_id);
**功能**：通过ftok返回的是根据文件（pathname）信息和计划编号（proj_id）合成的IPC key键值。
**返回值**：成功：返回key_t值（即IPC键值）；失败：-1，错误原因在error中
**参数**：
pathname：指定的文件，此文件必须存在且可存取
proj_id：计划代号（project ID）===>"proj_id值的意义"让一个文件也能生成多个IPC key键值。ftok利用同一文件最多可得到IPC key键值0xff（即256）个，因为ftok只取proj_id值二进制的后8位，即16进制的后两位与文件信息合成IPC key键值。

~~~c++
#include <stdio.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
int main()
{
    int shmid;
    char *shmaddr;
    key_t key;
    key=ftok(".",1);
    shmid=shmget(key,1024*4,IPC_CREAT|0666);

    if(shmid==-1)
    {
        printf("shmget() error!");
        exit(-1);
    }

    shmaddr = (char *)shmat(shmid,0,0);
    printf("shmat success\n");
    strcpy(shmaddr,"where are you!I was in London.");
    sleep(5);//给予时间给另一个程序读取内存，然后再删除共享内存内容。
    shmdt(shmaddr);
    shmctl(shmid,IPC_RMID,0);
    printf("quit\n");
    return 0;
}
~~~

~~~c++
#include <stdio.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
int main()
{
    int shmid;
    char *shmaddr;
    key_t key;
    key=ftok(".",1);
    shmid=shmget(key,1024*4,0);

    if(shmid == -1)
    {
        printf("shmget() error!\n");
        exit(1);
    }

    shmaddr = (char *)shmat(shmid,0,0);
    printf("shmat success!\n");
    printf("read:%s\n",shmaddr);

    sleep(5);
    shmdt(shmaddr);
    return 0;
}
~~~